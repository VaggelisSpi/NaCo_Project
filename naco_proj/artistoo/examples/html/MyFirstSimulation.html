<!-- Page setup and title -->
<!DOCTYPE html>
<html lang="en">
<head><meta http-equiv="Content-Type" content="text/html;
charset=UTF-8">
<title>Test</title>
<style type="text/css"> 
body{
		font-family: "HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue",
		 Helvetica, Arial, "Lucida Grande", sans-serif;
	 padding : 15px;
	 max-width: 600px;
	 margin: auto;
}
td {
	 padding: 10px;
	 vertical-align: top;
}
</style>

<!-- Sourcing the cpm build -->
<!-- <script src="../../build/artistoo.js"></script> -->
<script src="./artistoo.js"></script>
<script src="./fpsmeter.min.js"></script>

<script>
"use strict"

let num_obstacles = 50, num_cells = 10, sim, meter

let config = {
    ndim : 2,
    field_size : [200,200],
	// first cell is the movable object, second is the obstacle
    conf : {
		// Basic CPM parameters
		torus : [true,true],						// Should the grid have linked borders?
		seed : 5,							// Seed for random number generation.
		T : 20,								// CPM temperature
		
		// Constraint parameters. 
		// Mostly these have the format of an array in which each element specifies the
		// parameter value for one of the cellkinds on the grid.
		// First value is always cellkind 0 (the background) and is often not used.

		// Adhesion parameters:
		// [[J_blue_blue, J_blue_black, J_b;ue_mat],
		//  [J_black_blue, J_blak_black, J_black_mat],
		//  [J_blue_mat, J_blak_mat, J_mat_mat],]
		// blue circles 		J: [[0,400,20], 
		// 	[400,0,50],
		// 	[20,50,0]],
		J: [[0,10,30], 
			[10,0,50],
			[30,50,0]],
		
		// VolumeConstraint parameters
		LAMBDA_V : [0,50,5],					// VolumeConstraint importance per cellkind
		V : [0,200,100],						// Target volume of each cellkind
		
		LAMBDA_P : [0,2,2],
		P : [0,180,2],

		// ActivityConstraint parameters
		LAMBDA_ACT : [0,200,0],				// ActivityConstraint importance per cellkind
		MAX_ACT : [0,80,0],		// Activity memory duration per cellkind
		ACT_MEAN : "geometric"				// Is neighborhood activity computed as a
		// "geometric" or "arithmetic" mean?
		
	},
	
	// Simulation setup and configuration
	simsettings : {
	
		// Cells on the grid
		NRCELLS : [num_cells,num_obstacles],					// Number of cells to seed for all
		// non-background cellkinds.
		// Runtime etc
		BURNIN : 500,
		RUNTIME : 1000,
		RUNTIME_BROWSER : "Inf",
		
		// Visualization
		CANVASCOLOR : "eaecef",
		CELLCOLOR : ["0000FF","000000"],
		ACTCOLOR : [true,false],					// Should pixel activity values be displayed?
		SHOWBORDERS : [true,true],				// Should cellborders be displayed?
		zoom : 2,							// zoom in on canvas with this factor.
		
		// Output images
		SAVEIMG : false,						// Should a png image of the grid be saved
		// during the simulation?
		IMGFRAMERATE : 1,					// If so, do this every <IMGFRAMERATE> MCS.
		SAVEPATH : "output/img/ManyCellsPrefDir",// ... And save the image in this folder.
		EXPNAME : "ManyCellsPrefDir",			// Used for the filename of output images.
		
		// Output stats etc
		STATSOUT : { browser: false, node: true }, // Should stats be computed?
		LOGRATE : 10							// Output stats every <LOGRATE> MCS.

	}
}

function initialize(){
		 /* 	The following functions are defined below and will be added to
	 	the simulation object. If Custom-methods above is set to false,
	 	this object is ignored and not used in the html/node files. */
	let custommethods = {
		initializeGrid : initializeGrid,
	}

    sim = new CPM.Simulation( config, custommethods )
	meter = new FPSMeter({left:"auto", right:"5px"})
    step()
}

function step(){
    sim.step()
	meter.tick()
    requestAnimationFrame( step )
}

/* The following custom methods will be added to the simulation object*/
function initializeGrid(){
	// add the initializer if not already there
	if( !this.helpClasses["gm"] ){ this.addGridManipulator() }

	// Seed the moving cells
	for (var i =0; i < num_cells; i+=1) {
		this.gm.seedCell( 1, 5 )
	}

	// Seed obstacles in equal spacing in the grid
	let x_size = this.C.extents[0]
	let y_size = this.C.extents[1]


	// Calculate how many rows we need to accommodate x points
    const rows = Math.ceil(Math.sqrt(num_obstacles));

    // Calculate the spacing between rows
    const row_spacing = x_size / (rows + 1); // +1 to account for edges

	let points = []
    let obstacles_placed = 0;
    for (let i = 0; i < rows; i++) {
        // Calculate how many points to place in this row
        const obstacles_in_row = Math.min(num_obstacles - obstacles_placed, rows);

        // Calculate the spacing between points in this row
        const col_spacing = x_size / (obstacles_in_row + 1); // +1 to account for edges

        for (let j = 0; j < obstacles_in_row; j++) {
            const point = {
                x: (j + 1) * col_spacing,
                y: (i + 1) * row_spacing
            };
            points.push(point);
            obstacles_placed++;
        }

        if (obstacles_placed >= num_obstacles) break; // Stop once we've reached the desired number of points
    }

	for( let p of points ){
		this.gm.seedCellAt( 2, [Math.floor(p.x),Math.floor(p.y)] )
	}
}

</script>
</head>

<body onload="initialize()">
	<h1>My experiment</h1>
	<p>It works.</p>
</body>
</html>